package window

import (
	"errors"
	"unsafe"

	"github.com/mkch/gg"
	"github.com/mkch/gw/internal/appmsg"
	"github.com/mkch/gw/menu"
	"github.com/mkch/gw/paint"
	"github.com/mkch/gw/util/callback"
	"github.com/mkch/gw/win32"
	"github.com/mkch/gw/win32/win32util"
	"golang.org/x/sys/windows"
)

type msgProc func(msg *win32.MSG) bool

var msgPreTranslatorMap = make(map[win32.HWND]msgProc)

func PreTranslateMessage(msg *win32.MSG) bool {
	if p := msgPreTranslatorMap[msg.Hwnd]; p != nil {
		if translated := p(msg); translated {
			return true
		}
	}
	if p := msgPreTranslatorMap[win32.GetActiveWindow()]; p != nil {
		return p(msg)
	}
	return false
}

// LookupWindowBase looks up the WindowBase associated with hwnd.
// It returns nil if not found.
func LookupWindowBase(hwnd win32.HWND) *WindowBase {
	return windowBaseMap[hwnd]
}

var windowBaseMap = make(map[win32.HWND]*WindowBase)

var wndProc = windows.NewCallback(func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM) win32.LRESULT {
	return windowBaseMap[hwnd].realWndProc(hwnd, message, wParam, lParam)
})

type WndProc func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM, prevWndProc win32.WndProc) win32.LRESULT

type msgListenerMap map[MsgListenerKey]func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM)

// MsgListenerKey represents a message listener added by WindowBase.AddMsgListener.
type MsgListenerKey struct {
	m      *msgListenerMap
	unique *uintptr // generated by new(uintptr)
}

// Remove removes the listener.
func (k MsgListenerKey) Remove() {
	delete(*k.m, k)
}

type WindowBase struct {
	OnLButtonUp    func(opt MouseClickOpt, x int, y int)
	OnLButtonDown  func(opt MouseClickOpt, x int, y int)
	OnRButtonUp    func(opt MouseClickOpt, x int, y int)
	OnRButtonDown  func(opt MouseClickOpt, x int, y int)
	paintCb        *callback.Callback[*paint.PaintData, struct{}]
	msgListeners   map[win32.UINT]msgListenerMap
	values         map[any]any
	hwnd           win32.HWND
	wndProc        WndProc
	prevWndProc    win32.WndProc
	nativeWndProc  uintptr
	menu           *menu.Menu
	menuAccel      []win32.ACCEL // Accelerator table of the window menu.
	popupMenuAccel []win32.ACCEL // Accelerator table of the popup menu(context menu).
	accelKeyTable  win32.HACCEL
}

func (w *WindowBase) Destroy() error {
	return win32.DestroyWindow(w.hwnd)
}

// setMsgPreTranslator sets a MsgProc to process a message sent to this window
// before TranslateMessage is called in the message loop.
// If p returns true, no further processing will be performed.
// A nil p removes the pre-translator.
func (w *WindowBase) setMsgPreTranslator(p msgProc) {
	if p == nil {
		delete(msgPreTranslatorMap, w.hwnd)
	}
	msgPreTranslatorMap[w.hwnd] = p
}

// SetWndProc sets the window procedure of w.
// It panics if wndProc is nil.
func (w *WindowBase) SetWndProc(wndProc WndProc) {
	if wndProc == nil {
		panic(errors.New("nil WndProc"))
	}
	oldProc, oldPrevProc := w.wndProc, w.prevWndProc
	w.prevWndProc = func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM) win32.LRESULT {
		return oldProc(hwnd, message, wParam, lParam, oldPrevProc)
	}
	w.wndProc = wndProc
}

func (w *WindowBase) HWND() win32.HWND {
	return w.hwnd
}

type MouseClickOpt win32.WPARAM

func (mk MouseClickOpt) Control() bool {
	return mk&win32.MK_CONTROL != 0
}

func (mk MouseClickOpt) LButton() bool {
	return mk&win32.MK_LBUTTON != 0
}

func (mk MouseClickOpt) MButton() bool {
	return mk&win32.MK_MBUTTON != 0
}

func (mk MouseClickOpt) RDown() bool {
	return mk&win32.MK_RBUTTON != 0
}

func (mk MouseClickOpt) Shift() bool {
	return mk&win32.MK_SHIFT != 0
}

func (mk MouseClickOpt) XButton1() bool {
	return mk&win32.MK_XBUTTON1 != 0
}

func (mk MouseClickOpt) XButton2() bool {
	return mk&win32.MK_XBUTTON2 != 0
}

func (w *WindowBase) realWndProc(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM) win32.LRESULT {
	switch message {
	case win32.WM_DESTROY:
		if w.menu != nil {
			// Although the menu is automatically destroyed by the system when the window is destroyed,
			// the cleanup for menuMap is not called then.

			// Don't do this after WM_DESTROY because SetMenu(0) causes WM_SIZE and related messages
			// to be sent which may cause problems in event handlers if the window handle is already destroyed.
			win32.SetMenu(w.hwnd, 0)
			// Manually destroy the menu to avoid resource leak in menuMap.
			w.menu.Destroy()
			w.hwnd = 0
		}
	case win32.WM_NCDESTROY:
		if w.accelKeyTable != 0 {
			win32.DestroyAcceleratorTable(w.accelKeyTable)
			w.accelKeyTable = 0
		}
		delete(windowBaseMap, hwnd)
		delete(msgPreTranslatorMap, hwnd)
	}
	return w.wndProc(hwnd, message, wParam, lParam, w.prevWndProc)
}

func (w *Window) setMenu(menu *menu.Menu) error {
	var hMenu win32.HMENU
	if menu != nil {
		hMenu = menu.HMENU()
	}
	if err := win32.SetMenu(w.hwnd, hMenu); err != nil {
		return err
	}
	if w.menu != nil {
		w.menu.OnAccelKeyChanged = nil
	}
	w.menu = menu
	if w.menu != nil {
		var err error
		if w.menuAccel, err = w.menu.AccelKeyTable(); err != nil {
			return err
		}
		w.menu.OnAccelKeyChanged = func() (err error) {
			if w.menuAccel, err = w.menu.AccelKeyTable(); err != nil {
				return
			}
			if err = w.rebuildAccelTable(); err != nil {
				return
			}
			return
		}
		w.setMsgPreTranslator(w.preTranslateMessage)
	} else {
		w.setMsgPreTranslator(nil)
		w.menuAccel = nil
	}

	return w.rebuildAccelTable()
}

type PopupMenuSpec struct {
	Flags   win32.TRACK_POPUP_MENU_FLAG
	X, Y    win32.LONG // Screen coordinates.
	Exclude *win32.RECT
}

// TrackPopupMenu tracks a popup menu.
// If spec is nil, default flag, empty exclude RECT and GetCursorPos() are used.
func (w *WindowBase) TrackPopupMenu(menu *menu.Menu, spec *PopupMenuSpec) error {
	var flags win32.TRACK_POPUP_MENU_FLAG
	var pt = &win32.POINT{}
	var params *win32.TPMPARAMS

	if spec != nil {
		// Notify message is needed.
		if spec.Flags&win32.TPM_NONOTIFY != 0 {
			return errors.New("invalid param: TPM_NONOTIFY is not allowed")
		}
		flags = spec.Flags
		pt.X = win32.LONG(spec.X)
		pt.Y = win32.LONG(spec.Y)
		if spec.Exclude != nil {
			params = &win32.TPMPARAMS{
				Size:    win32.UINT(unsafe.Sizeof(win32.TPMPARAMS{})),
				Exclude: *spec.Exclude,
			}
		}
	} else {
		var err error
		pt, err = win32.GetCursorPos()
		if err != nil {
			return err
		}
		flags = gg.If(win32.GetSystemMetrics(win32.SM_MENUDROPALIGNMENT) != 0, win32.TPM_RIGHTALIGN, win32.TPM_LEFTALIGN)
	}

	if t, err := menu.AccelKeyTable(); err != nil {
		return err
	} else {
		w.popupMenuAccel = t
		w.rebuildAccelTable()
		defer func() {
			w.popupMenuAccel = nil
			w.rebuildAccelTable()
		}()
	}
	_, err := win32.TrackPopupMenuEx(menu.HMENU(), flags, win32.INT(pt.X), win32.INT(pt.Y), w.HWND(), params)
	return err
}

func (w *WindowBase) rebuildAccelTable() error {
	if w.accelKeyTable != 0 {
		if err := win32.DestroyAcceleratorTable(w.accelKeyTable); err != nil {
			return err
		}
		w.accelKeyTable = 0
	}

	var table []win32.ACCEL
	table = append(table, w.menuAccel...)
	table = append(table, w.popupMenuAccel...)

	if w.menu != nil {
		mt, err := w.menu.AccelKeyTable()
		if err != nil {
			return err
		}
		table = append(table, mt...)
	}
	if len(table) > 0 {
		h, err := win32.CreateAcceleratorTableW(table)
		if err != nil {
			return err
		}
		w.accelKeyTable = h
	}
	return nil
}

func (w *WindowBase) Show(cmd win32.SHOW_WINDOW_CMD) {
	win32.ShowWindow(w.hwnd, cmd)
}

func (w *WindowBase) SetText(text string) error {
	return win32util.SetWindowText(w.hwnd, text)
}

func (w *WindowBase) Text() (string, error) {
	return win32util.GetWindowText(w.hwnd)
}

func (w *WindowBase) DPI() (win32.UINT, error) {
	return win32.GetDpiForWindow(w.hwnd)
}

func (w *WindowBase) GetClientRect() (*win32.RECT, error) {
	var rect win32.RECT
	if err := win32.GetClientRect(w.hwnd, &rect); err != nil {
		return nil, err
	}
	return &rect, nil
}

func (w *WindowBase) InvalidateRect(rect *win32.RECT, eraseBk bool) error {
	return win32.InvalidateRect(w.hwnd, rect, eraseBk)
}

// wiErrAlreadyAttached is returned by Attach if the HWND or *WindowBase
// is already attached.
var ErrAlreadyAttached = errors.New("already attached")

func Query(hwnd win32.HWND) *WindowBase {
	return windowBaseMap[hwnd]
}

func Attach(hwnd win32.HWND, window *WindowBase) error {
	if Query(hwnd) != nil {
		return ErrAlreadyAttached
	}
	if proc, err := win32.GetWindowLongPtrW(hwnd, win32.GWLP_WNDPROC); err != nil {
		return err
	} else if proc == win32.LONG_PTR(wndProc) {
		return ErrAlreadyAttached
	}

	if oldProc, err := win32.SetWindowLongPtrW(hwnd, win32.GWLP_WNDPROC, win32.LONG_PTR(wndProc)); err != nil {
		return err
	} else {
		windowBaseMap[hwnd] = window
		window.nativeWndProc = uintptr(oldProc)
		window.prevWndProc = func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM) win32.LRESULT {
			if window.msgListeners != nil {
				if listeners := window.msgListeners[message]; listeners != nil {
					for _, l := range listeners {
						l(hwnd, message, wParam, lParam)
					}
				}
			}
			switch message {
			case win32.WM_CTLCOLORSTATIC:
				if ret, err := win32.SendMessageW(win32.HWND(lParam), appmsg.REFLECT_CTLCOLORSTATIC, wParam, lParam); err == nil && ret != 0 {
					return ret
				}
			case win32.WM_COMMAND:
				if lParam != 0 {
					win32.SendMessageW(win32.HWND(lParam), appmsg.REFLECT_COMMAND, wParam, lParam)
				} else {
					menu.OnWmCommand(win32.LOWORD(wParam))
				}
			case win32.WM_LBUTTONUP:
				if window.OnLButtonUp != nil {
					window.OnLButtonUp(MouseClickOpt(wParam), int(win32.LOWORD(uintptr(lParam))), int(win32.HIWORD(uintptr(lParam))))
				}
			case win32.WM_LBUTTONDOWN:
				if window.OnLButtonDown != nil {
					window.OnLButtonDown(MouseClickOpt(wParam), int(win32.LOWORD(uintptr(lParam))), int(win32.HIWORD(uintptr(lParam))))
				}
			case win32.WM_RBUTTONUP:
				if window.OnRButtonUp != nil {
					window.OnRButtonUp(MouseClickOpt(wParam), int(win32.LOWORD(uintptr(lParam))), int(win32.HIWORD(uintptr(lParam))))
				}
			case win32.WM_RBUTTONDOWN:
				if window.OnRButtonDown != nil {
					window.OnRButtonDown(MouseClickOpt(wParam), int(win32.LOWORD(uintptr(lParam))), int(win32.HIWORD(uintptr(lParam))))
				}
			case win32.WM_PAINT:
				if window.paintCb == nil {
					break
				}
				var ps win32.PAINTSTRUCT
				dc, err := win32.BeginPaint(hwnd, &ps)
				if err != nil {
					panic(err)
				}
				defer win32.EndPaint(hwnd, &ps)
				window.paintCb.Call(&paint.PaintData{
					DC:    dc,
					Erase: ps.Erase != 0,
					Rect:  ps.RcPaint,
				})
				return 0 // Not calling default.
			case win32.WM_DPICHANGED:
				// For top level windows.

				// To defeat go vet (possible misuse of unsafe.Pointer).
				// Should be suggested := (*win32.RECT)(unsafe.Pointer(uintptr(lParam)))
				suggested := (*win32.RECT)(unsafe.Pointer(uintptr(unsafe.Pointer(nil)) + uintptr(lParam)))
				win32.SetWindowPos(hwnd, 0,
					win32.INT(suggested.Left), win32.INT(suggested.Top), win32.INT(suggested.Width()), win32.INT(suggested.Height()),
					win32.SWP_NOZORDER|win32.SWP_NOACTIVATE)
			}
			return win32.CallWindowProcW(window.nativeWndProc, hwnd, message, wParam, lParam)
		}
		window.wndProc = func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM, prevWndProc win32.WndProc) win32.LRESULT {
			return prevWndProc(hwnd, message, wParam, lParam)
		}
	}
	window.hwnd = hwnd
	return nil
}

func (w *WindowBase) AddPaintCallback(f func(data *paint.PaintData, prev func(*paint.PaintData))) {
	if w.paintCb == nil {
		w.paintCb = callback.New(func(data *paint.PaintData, prev func(*paint.PaintData) (struct{}, error)) (_ struct{}, _ error) {
			return
		}, func(*paint.PaintData) (_ struct{}, _ error) { return })
	}
	w.paintCb.Add(func(data *paint.PaintData, prev func(*paint.PaintData) (struct{}, error)) (struct{}, error) {
		f(data, func(data2 *paint.PaintData) { prev(data2) })
		return struct{}{}, nil
	})
}

func (w *WindowBase) AddDoubleBufferingPaintCallback() (err error) {
	rect, err := w.GetClientRect()
	if err != nil {
		return
	}
	windowDC, err := win32.GetDC(w.hwnd)
	if err != nil {
		return
	}
	buffer, err := paint.NewBuffer(windowDC, int(rect.Width()), int(rect.Height()))
	if err != nil {
		return
	}
	w.AddPaintCallback(func(data *paint.PaintData, prev func(*paint.PaintData)) {
		// call previous callback with the buffer
		prev(&paint.PaintData{
			DC:    buffer.HDC(),
			Erase: data.Erase,
			Rect:  data.Rect,
		})
		client, err := w.GetClientRect()
		if err != nil {
			panic(err)
		}
		// copy the buffer to the paint DC
		err = win32.BitBlt(data.DC, 0, 0, int(client.Width()), int(client.Height()),
			buffer.HDC(), 0, 0,
			win32.SRCCOPY)
		if err != nil {
			panic(err)
		}
	})

	// Listen to WM_DISPLAYCHANGE to recreate the buffer
	root, err := win32.GetAncestor(w.hwnd, win32.GA_ROOT)
	if err != nil {
		return
	}
	rootWin := LookupWindowBase(root)
	if rootWin == nil {
		return errors.New("cannot find root window")
	}
	displayChangeKey := rootWin.AddMsgListener(win32.WM_DISPLAYCHANGE, func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM) {
		gg.MustOK(buffer.Destroy())
		rect := gg.Must(w.GetClientRect())
		if !win32.ReleaseDC(w.hwnd, windowDC) {
			panic("failed to release DC")
		}
		windowDC = gg.Must(win32.GetDC(w.hwnd))
		buffer = gg.Must(paint.NewBuffer(windowDC, int(rect.Width()), int(rect.Height())))
	})

	w.SetWndProc(func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM, prevWndProc win32.WndProc) win32.LRESULT {
		switch message {
		case win32.WM_DESTROY:
			if !win32.ReleaseDC(w.hwnd, windowDC) {
				panic("failed to release DC")
			}
			gg.MustOK(buffer.Destroy())
			displayChangeKey.Remove()
		case win32.WM_SIZE:
			rect := gg.Must(w.GetClientRect())
			gg.MustOK(buffer.Resize(int(rect.Width()), int(rect.Height())))
		}
		return prevWndProc(hwnd, message, wParam, lParam)
	})

	return nil
}

// AddMsgListener adds a listener that is called when the message is received in the window procedure.
// To remove the listener, call Remove() of the returned MsgListenerKey.
func (w *WindowBase) AddMsgListener(message win32.UINT,
	listener func(hwnd win32.HWND, message win32.UINT, wParam win32.WPARAM, lParam win32.LPARAM)) MsgListenerKey {
	if listener == nil {
		panic("nil listener")
	}
	if w.msgListeners == nil {
		w.msgListeners = make(map[win32.UINT]msgListenerMap)
	}

	listeners := w.msgListeners[message]
	if listeners == nil {
		listeners = make(msgListenerMap)
		w.msgListeners[message] = listeners
	}
	key := MsgListenerKey{&listeners, new(uintptr)}
	listeners[key] = listener
	return key
}

// Value returns the value associated with this window for key, or nil
// if no value is associated with key.
// See Context.Value() in context package for the concept and usage of associated value.
func (w *WindowBase) Value(key any) any {
	if w.values == nil {
		return nil
	}
	return w.values[key]
}

// Value sets the value associated with this window for key.
// Setting A nil value deletes the value associated with key if any.
// See Context.Value() in context package for the concept and usage of associated value.
func (w *WindowBase) SetValue(key, value any) {
	if value == nil {
		delete(w.values, key)
		return
	}
	if w.values == nil {
		w.values = make(map[any]any)
	}
	w.values[key] = value
}
